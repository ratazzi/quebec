//! `SeaORM` Entity, @generated by sea-orm-codegen 1.1.0

use crate::context::TableConfig;
use crate::query_builder;
use sea_orm::entity::prelude::*;
use sea_orm::{DatabaseTransaction, DbErr};
use tracing::info;

// Define the Retryable trait
pub trait Retryable {
    /// Retry a failed job by moving it from failed_executions to ready_executions
    async fn retry(
        &self,
        txn: &DatabaseTransaction,
        table_config: &TableConfig,
    ) -> Result<(), DbErr>;

    /// Retry all failed jobs by moving them from failed_executions to ready_executions
    async fn retry_all(
        &self,
        txn: &DatabaseTransaction,
        table_config: &TableConfig,
    ) -> Result<u64, DbErr>;
}

// Define the Discardable trait
pub trait Discardable {
    /// Discard a failed job by removing it from failed_executions and optionally marking the job as finished
    async fn discard(
        &self,
        txn: &DatabaseTransaction,
        table_config: &TableConfig,
    ) -> Result<(), DbErr>;

    /// Discard all failed jobs by removing them from failed_executions and optionally marking the jobs as finished
    async fn discard_all(
        &self,
        txn: &DatabaseTransaction,
        table_config: &TableConfig,
    ) -> Result<u64, DbErr>;
}

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq)]
#[sea_orm(table_name = "solid_queue_failed_executions")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i64,
    #[sea_orm(unique)]
    pub job_id: i64,
    #[sea_orm(column_type = "Text", nullable)]
    pub error: Option<String>,
    pub created_at: DateTime,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(
        belongs_to = "super::quebec_jobs::Entity",
        from = "Column::JobId",
        to = "super::quebec_jobs::Column::Id",
        on_update = "NoAction",
        on_delete = "Cascade"
    )]
    SolidQueueJobs,
}

impl Related<super::quebec_jobs::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::SolidQueueJobs.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}

// Implement Retryable for Model
impl Retryable for Model {
    async fn retry(
        &self,
        txn: &DatabaseTransaction,
        table_config: &TableConfig,
    ) -> Result<(), DbErr> {
        // 1. Find failed job record
        let job_result = query_builder::jobs::find_by_id(txn, table_config, self.job_id).await?;

        if let Some(job) = job_result {
            // 2. Add job to ready_executions table
            query_builder::ready_executions::insert(
                txn,
                table_config,
                job.id,
                &job.queue_name,
                job.priority,
            )
            .await?;

            // 3. Delete failed execution record
            query_builder::failed_executions::delete_by_job_id(txn, table_config, self.job_id)
                .await?;

            info!("Retried failed job {}", self.job_id);
            Ok(())
        } else {
            Err(DbErr::Custom(format!(
                "Job with ID {} not found",
                self.job_id
            )))
        }
    }

    async fn retry_all(
        &self,
        txn: &DatabaseTransaction,
        table_config: &TableConfig,
    ) -> Result<u64, DbErr> {
        // 1. Get all failed job records
        let failed_executions =
            query_builder::failed_executions::find_all(txn, table_config).await?;

        if failed_executions.is_empty() {
            return Ok(0);
        }

        let job_ids: Vec<i64> = failed_executions
            .iter()
            .map(|execution| execution.job_id)
            .collect();

        // 2. Get all related job information
        let jobs = query_builder::jobs::find_by_ids(txn, table_config, job_ids.clone()).await?;

        // 3. Add all jobs to ready_executions table
        for job in &jobs {
            query_builder::ready_executions::insert(
                txn,
                table_config,
                job.id,
                &job.queue_name,
                job.priority,
            )
            .await?;
        }

        // 4. Delete all failed execution records
        let count =
            query_builder::failed_executions::delete_by_job_ids(txn, table_config, job_ids).await?;

        info!("Retried all {} failed jobs", jobs.len());
        Ok(count)
    }
}

// Implement Discardable for Model
impl Discardable for Model {
    async fn discard(
        &self,
        txn: &DatabaseTransaction,
        table_config: &TableConfig,
    ) -> Result<(), DbErr> {
        // 1. Find job record
        let job_result = query_builder::jobs::find_by_id(txn, table_config, self.job_id).await?;

        if job_result.is_some() {
            // 2. Update job status to completed
            query_builder::jobs::mark_finished(txn, table_config, self.job_id).await?;

            // 3. Delete failed execution record
            query_builder::failed_executions::delete_by_job_id(txn, table_config, self.job_id)
                .await?;

            info!("Discarded failed job {}", self.job_id);
            Ok(())
        } else {
            Err(DbErr::Custom(format!(
                "Job with ID {} not found",
                self.job_id
            )))
        }
    }

    async fn discard_all(
        &self,
        txn: &DatabaseTransaction,
        table_config: &TableConfig,
    ) -> Result<u64, DbErr> {
        // 1. Get all failed job records
        let failed_executions =
            query_builder::failed_executions::find_all(txn, table_config).await?;

        if failed_executions.is_empty() {
            return Ok(0);
        }

        let job_ids: Vec<i64> = failed_executions
            .iter()
            .map(|execution| execution.job_id)
            .collect();

        // 2. Update all related jobs to completed status
        for job_id in &job_ids {
            query_builder::jobs::mark_finished(txn, table_config, *job_id).await?;
        }

        // 3. Delete all failed execution records
        let count =
            query_builder::failed_executions::delete_by_job_ids(txn, table_config, job_ids).await?;

        info!("Discarded all {} failed jobs", count);
        Ok(count)
    }
}

// Implement Retryable for Entity
impl Retryable for Entity {
    async fn retry(
        &self,
        _txn: &DatabaseTransaction,
        _table_config: &TableConfig,
    ) -> Result<(), DbErr> {
        // Since Entity doesn't have a specific job_id, this method needs a different implementation
        Err(DbErr::Custom(
            "Cannot retry a job from Entity, please use a Model instance instead".to_string(),
        ))
    }

    async fn retry_all(
        &self,
        txn: &DatabaseTransaction,
        table_config: &TableConfig,
    ) -> Result<u64, DbErr> {
        // 1. Get all failed job records
        let failed_executions =
            query_builder::failed_executions::find_all(txn, table_config).await?;

        if failed_executions.is_empty() {
            return Ok(0);
        }

        let job_ids: Vec<i64> = failed_executions
            .iter()
            .map(|execution| execution.job_id)
            .collect();

        // 2. Get all related job information
        let jobs = query_builder::jobs::find_by_ids(txn, table_config, job_ids.clone()).await?;

        // 3. Add all jobs to ready_executions table
        for job in &jobs {
            query_builder::ready_executions::insert(
                txn,
                table_config,
                job.id,
                &job.queue_name,
                job.priority,
            )
            .await?;
        }

        // 4. Delete all failed execution records
        let count =
            query_builder::failed_executions::delete_by_job_ids(txn, table_config, job_ids).await?;

        info!("Retried all {} failed jobs", jobs.len());
        Ok(count)
    }
}

// Implement Discardable for Entity
impl Discardable for Entity {
    async fn discard(
        &self,
        _txn: &DatabaseTransaction,
        _table_config: &TableConfig,
    ) -> Result<(), DbErr> {
        // Since Entity doesn't have a specific job_id, this method needs a different implementation
        Err(DbErr::Custom(
            "Cannot discard a job from Entity, please use a Model instance instead".to_string(),
        ))
    }

    async fn discard_all(
        &self,
        txn: &DatabaseTransaction,
        table_config: &TableConfig,
    ) -> Result<u64, DbErr> {
        // 1. Get all failed job records
        let failed_executions =
            query_builder::failed_executions::find_all(txn, table_config).await?;

        if failed_executions.is_empty() {
            return Ok(0);
        }

        let job_ids: Vec<i64> = failed_executions
            .iter()
            .map(|execution| execution.job_id)
            .collect();

        // 2. Update all related jobs to completed status
        for job_id in &job_ids {
            query_builder::jobs::mark_finished(txn, table_config, *job_id).await?;
        }

        // 3. Delete all failed execution records
        let count =
            query_builder::failed_executions::delete_by_job_ids(txn, table_config, job_ids).await?;

        info!("Discarded all {} failed jobs", count);
        Ok(count)
    }
}
